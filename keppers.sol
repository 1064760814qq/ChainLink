// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

// KeeperCompatible.sol imports the functions from both ./KeeperBase.sol and
// ./interfaces/KeeperCompatibleInterface.sol
import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract Counter is KeeperCompatibleInterface,Ownable {
    /**
    * Public counter variable
    */
    uint public counter;
    bool public state;
    bool public dataHowToCall;

    address public VRF;
    bytes private execData;

    /**
    * Use an interval in seconds and a timestamp to slow execution of Upkeep
    */
    uint public  interval;
    uint public lastTimeStamp;

    constructor(uint updateInterval,address _VRFORDES) {
      interval = updateInterval;
      lastTimeStamp = block.timestamp;
      VRF = _VRFORDES;
      counter = 0;
    }

    function setInterval(uint updateInterval) public onlyOwner{
        interval = updateInterval;
    }

    function stateSwitch(bool _state,bool _dataHowToCall) public onlyOwner{
        state = _state;
        dataHowToCall = _dataHowToCall;
    }

    function requestData(address buyer, uint tokenId,string memory _tokenURI)
        internal
        pure
        returns(bytes memory)
    {
        return abi.encodeWithSignature("requestRandomWords(address,uint256,string)", buyer, tokenId,_tokenURI);
    }

    function setData(bytes memory data) public onlyOwner {
        execData = data;
    }


    function callExecute(address dest,bytes memory data)
    internal
    returns (bool result)
    {
        bytes memory tmp;
        (result, tmp) = dest.call(data);
        return result;
    }


    function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        upkeepNeeded = (( (block.timestamp - lastTimeStamp) > interval) && state);
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if (( (block.timestamp - lastTimeStamp) > interval) && state) {
            





            lastTimeStamp = block.timestamp;
            counter = counter + 1;
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }
}